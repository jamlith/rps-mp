		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
		|   rps.js															  |
		|		multiplayer rock paper scissors 		  |
		|		using firebase and javascript.			  |
		\________________________________________*/

// set vars
var name = null;
var id = null;
var slot = null;
// extra stats that wont be sent to the database
var stats = {
	rock: { count: 0, wins: 0, losses: 0, ties: 0 },
	paper: { count: 0, wins: 0, losses: 0, ties: 0 },
	scissors: { count: 0, wins: 0, losses: 0, ties: 0 },
	total: 0
}


// Wait for the document to load completely before executing any code.
// jQuery has the function $(document).ready(func() { ... }) to achieve
// this.

//------------------------------------------------------------------------------
// database 'folders' i plan to use:
//    cxs/						+ cxs ('connections'): a list of a random string
//      <uid>: true,			+ of #'s and letters  for each client connected
//      <uid>: true...			+ to the firebase serbver through this page
//------------------------------------------------------------------------------
// 	  users/
//		player1: {name: <username>, id: <user-id>, wins: <x>, losses: <y>, ties: <z>},
//		player2: {name: <username>, id: <user-id>, wins: <x>, losses: <y>, ties: <z>}
//
// users: the data unique to each user, such as username, slot, and scores.  the id same unique string we generated by pushing a new item into the CX list...
//------------------------------------------------------------------------------
//	  moves/					+ moves: the field that will hold each player's
//		<slot>: <move>,			+ decision for the pending round. the slot will
//		<slot>: <move>...		+ be either <1> -or- <2>.  all other values are
//								+ invalid.  the game will be monitoring the folder,
//								+ triggering the code to evaluate a winner once
//								+ both players have locked in a move.
//-----------------------------------------------------------------------------
//	  msgs/
//		<sender-id>, <msg>, <timestamp>, <style>,
//		<sender-id>, <msg>, <timestamp>, <style>...
//
//	a list of chat messages that will be used to populate the chat window...
//  as of now the timestamp and style values aren't implemented, but in the
//  future i may use them to display message age, either in-line or as a
//  tooltip. and also to allow the user to change text color/weight for
//  special taunts, possibly as a reward for a winning streak.
//------------------------------------------------------------------------------


var fb = {
	uid: null,
	db: firebase.database(),
	p1name: false,
	p2name: false,
	wins: 0,
	ties: 0,
	losses: 0,
	stats: { 'count': { 'rock': 0, 'paper': 0, 'scissors': 0, 'total': 0 }},
	init: function() {
	// fb.init() - "Initial State" :: should be the run as soon as the page is done`
	// loading.  will hide any objects that dont apply until later in the connection
	// process (specifically i will be hiding the rock, paper, and scissors buttons
	// score, and the chat form until the user connected and has chosen his name.
	// also, once the name field and the join button have been used i will be hiding
	// them as well.)  Also, will set up the triggers for pertinent changes in the
	// database, along with the code to be run on those events. Will add myself to a
	// list of connections @ <cxs> with unique key that will be acting as my user id,
	// and with a value of TRUE, though this value will be inconsequential since its
	// only the unique key i will be using.  also, will set the cxs data i added to
	// self-destruct in the event that i lose connection to the server.
	// list of connections will be at /cxs/, users at /users/, next moves at /moves/
			// this is just to set initial values and set listeners where needed
		var cxRef = this.db.ref('cxs/');			// get the ref functions ready
		var msgRef = this.db.ref('msgs/');			// for each part of the database
		var usrRef = this.db.ref('users/');			// i want deleted when i disconnect.
		var moveRef = this.db.ref('moves/');
		var conRef = this.db.ref('.info/connected');

	// Monitor /.info/connected/ for any changes in value.  This field will be true
	// while the user is connected to the database, and false otherwise.
		conRef.on('value', function(data) {
			// if connected, the returned value will be TRUE.
			if (data.val()) {
		// code to run if cx state changed to connected...

			// +generate a unique ID string for ourselves, then add it to the connection list
				var cxk = cxRef.push(true);			//  the $REF.push($VAL) method appends the
			// provided value to the referenced list with a randomly generated unique
			// key of letters, numbers and symbols.
			// as its argument.  if list didn't exist it will be created.
			// referenced list (cxRef in this case) to the list that <ref> is pointing to (will create it if it doesnt exist)
				this.uid = cxk.key;					//	firebase generates a unique key
				id = cxk.key;						// 	for the value you store using
				cxk.onDisconnect().remove();		//	.push(val), e.g. the cmd we just
				console.log('cxk: ' + cxk.key);		// 	used created /{cxs: {<unique-key>: true}}
				$('#p1form').fadeIn();
				$('#p2form').fadeIn();				//  make the name forms visible
				printAlert("Connected to database... Set your name and choose a seat to begin playing.");
			 // the new key is returned by the push func, so i used cxk(for connection key).  since
			 // the data is returned in an object you need to use the .key method to return the
			 // id string.
		 } else {
		// code to run if the connection was dropped...
			//  Return the page to the initial state (hide game and chat controls,
			//  set the username headers back to the default.and set the variables
			//   and scoreboards back to 0 and null.
			$('#chatform').fadeOut(); 				// message field and send button
			$('#p1form').fadeOut(); 					// form to set username and choose player slot
			$('#p1play').fadeOut(); 				// scoreboard and gameplay buttons
			$('#p1_label_form').text('Playert 1'); 	// headers
			$('#p1_label_play').text('Player 1');  	// headers
			$('#p1unlabel').text('N/A'); 			// Scoreboard username label
			$('#p1winlabel').text('0');				// P1's win count
			$('#p1loselabel').text('0');			// P1's lose count
			$('#p1tielabel').text('0');				// P1's tie count
			$('#p2form').fadeOut(); 					// form to set username and choose player slot
			$('#p2play').fadeOut(); 				// scoreboard and gameplay buttons
			$('#p2_label_form').text('Playert 2'); 	// headers
			$('#p2_label_play').text('Player 2');  	// headers
			$('#p2unlabel').text('N/A'); 			// Scoreboard username label
			$('#p2winlabel').text('0');				// P2's win count
			$('#p2loselabel').text('0');			// P2's lose count
			$('#p2tielabel').text('0');				// P2's tie count
			this.p1name = null;						// reset object attributes
			this.p2name = null;
			this.uid = null;
			this.wins = 0;
			this.losses = 0;
			this.ties = 0;
			var d = new Date();
			var tstamp = '[' + d.getHours() + ':' + d.getMinutes() + '.' + d.getSeconds() + '] ';
			this.printAlert(tstamp + "Lost connection to the server... reseting the game.");
		});  // END conRef listener
		//listen for players joining
		usrRef.on('child_added', function(snapshot) {
			console.log("usr onChild");
			if (snapshot.child('player1').exists()) {
				console.log("p1 exists");
				if (this.uid == snapshot.val().player1.id) {
					console.log("p1 is user");
					name = player1.name;
					$("p1_label_form").text(name);
					$("p1_label_play").text(name);
				}
				$('#p1form').fadeOut();
				$('#p1unlabel').text(snapshot.val().player1.name);
				$('#p1winlabel').text(snapshot.val().player1.wins);
				$('#p1tielabel').text(snapshot.val().player1.ties);
				$('#p1losslabel').text(snapshot.val().player1.losses);
				$('#p1play').fadeIn();
				$('#chatform').fadeIn();
			}
			if (snapshot.child('player2').exists()) {
				this.p2name = snapshot.val().player2.name;
				if (this.uid == snapshot.val().player2.id) {
					console.log("user is p2");
					name = player2.namej
				}
				$('#p2form').fadeOut();
				$('#p2unlabel').text(snapshot.val().player2.name);
				$('#p2winlabel').text(snapshot.val().player2.wins);
				$('#p2tielabel').text(snapshot.val().player2.ties);
				$('#p2losslabel').text(snapshot.val().player2.losses);
				$('#p2play').fadeIn();
				$('#chatform').fadeIn();
			};
		});
		//listen for players leaving
		usrRef.on('child_removed', function(snapshot) {
			if (! snapshot.child('player1').exists()) {
		 		this.p1name = null;
				$('#p1play').fadeOut();
				$('#p1form').fadein();
		 		$('#p1unlabel').text('N/A');
				$('#p1winlabel').text(0);
				$('#p1tielabel').text(0);
				$('#p1losslabel').text(0);
	 		}
	  		if (! snapshot.child('player2').exists()) {
				this.p2name = null;
				$('#p2play').fadeOut();
				$('#p2form').fadein();
				$('#p2unlabel').text('N/A');
				$('#p1_label_form').val.
				$('#p2winlabel').text(0);
				$('#p2tielabel').text(0);
				$('#p2losslabel').text(0);
			 }
		});
		// listen for chat messages
		msgRef.on('child_added', function(snapshot) {
			var author_id = snapshot.val().authid;
			var message = snapshot.val().msg;
			var tstamp = snapshot.val().timestamp;
			this.printMessage(author_id, message, tstamp);
		});
	},
	bindName: function(pnum, name) {
	// Binds the user 'name' to the player slot 'num'.
		var usrRef = this.db.ref('users/');			// create a db REF obj pointing to the user data
		console.log('bindName('pnum + ", " + name + ');');
		if (pnum == 1 && this.p1name == false) {
			console.log("p1 true");
			this.p1name = name;
			usrRef.update({ 'player1': { 'name': name, 'id': this.uid, 'wins': 0, 'losses': 0, 'ties': 0 }});
			// delete this entry upon disconnect
			usrRef.onDisconnect().remove();
			return true
		} else if (pnum == 2 && this.p2name == false) {
			console.log("p2 true");
			this.p2name = name;
			usrRef.update({ 'player2': { 'name': name, 'id': this.uid, 'wins': 0, 'losses': 9, 'ties': 0 }});
			// delete this entry upon disconnect
			usrRef.onDisconnect().remove();
			return true
		} else {
			console.log("p2 true");
			return false;

		}
		console.log("false");
		return true;
	},
	updateStats: function(pnum, wins, losses, ties) {
		// updates UI when scores change
		var usrRef = this.db.ref('users/player' + pnum);
		usrRef.set({'wins': wins, 'losses': losses, 'ties': ties});
		$('#p' + pnum + 'winlabel').text(wins);
		$('#p' + pnum + 'losslabel').text(losses);
		$('#p' + pnum + 'tielabel').text(ties);
	},
	submitMove: function(pnum, move) {
		// registers a users decision, commits it to the db
		var usrRef = this.db.ref('users/');
		var moveRef = this.db.ref('moves/');
		usrRef.once('value').then(function(snapshot) {
			if (snapshot.child('player1').exists() && this.uid == snapshot.child('player1').child('id').val()) {
					var tok = moveRef.set({ 'player1': 'move' });
					// TODO: Display the selection for the user that made it (somehow)
			} else if (snapshot.child('player2').exists() && this.uid == snapshot.child('player2').child('id').val()) {
					var tok = moveRef.set({ 'player2': move });
			}
		});
	},
	printMessage: function(msg, timestamp=null, style=null) {
		console.log("pMsg: '" + msg + "'");
		var msgArr = msg.split(":");
		if (msgArr.length -ne 2) {
			// attempt to isolate usr and msg had unexpected results, reverting
			console.log("pMsg: aborted attempt to seperate msg and usermame...");
			var chatobj = $(msg).wrap($("<p>").addClass("chat-text"));
			console.log(chatobj);
			$('#chat').prepend(chatObj));
		} else {
			var musr = msgArr[0];
			var mcontent = msgArr[1];
			console.log('pMsg split user: "' + musr + '"');
			console.log('pMsg split content: "' + mcontent + '"');
			var newTag = $("<p>").append($("<span>").addClass("text-primary chat-text").append("username: ")).append("message");

		}
	}
	recordMessage: function(user, msg, tstamp=null, style=null) {
	// add a message to the msgs list.
		console.log("recordMessage()... ");	// log ::EVERYTHING:: ...fuck it.
		console.log(user + ": '" + msg + "'");
		var chatRef = this.db.ref('msgs/');		// define the REF obj for the chat section
		// if (tstamp === null) {
		// 	tstamp = Date.now();			// timestamps arent implemented, and probably never will be.
		// }
		var token = chatRef.push(user + ": ''" + msg + "'")		// added to list: { $UNIQUE_ID: 'user: message' }
		console.log("msg recorded... message id is '" + token.key + "'");
		chatRef.onDisconnect().remove();	// Destroy data apon loss of cxn
	},
	printAlert: function(msg, tstamp=false) {
		var pfix = ">$ ";
		if (tstamp) {
			var d = new Date();
			var tstring = '[' + d.getHours() + ':' + d.getMinutes() + '.' + d.getSeconds() + '] ';
			pfix = tstring;
		}
		var newTag = $("<span>").addClass('alert alert-info chat-alert').prepend(pfix + msg + ".");
		$("#chat").prepend(newTag);
	}
}  <!-- End of the fb object. -->

	// hide content that isn't relevant ATM
	$("#p1play").hide();		// hidden until user joins game
	$("#p2play").hide();		// ''
	$("#chatform").hide();		// ''
	$("#p1form").hide();		// hiddem until connected to the database
	$("#p2form").hide();		// ''
	// listen for player 1's join button.
	$("#p1join").click(function(event) {
		console.log("CLICK! #p1join");
		var pnum = 1;
		var nick=$("#p1nameinput").val();
		console.log("nick: '" + $nick + "'");
		if (nick.length < 1) {
			nick = "Regis Philbman";	// provide a moniker if user did not.
			console.log("Moniker intervension: " + nick);
		}
		var status = fb.bindName(pnum, nick);	// bind user to slot 1 (commit to db)
		if (status) {
			console.log('bindName returned true.');	// log this event, and set up for
			$('#p1play').fadeIn();					// gameplay... make the game
			$('#p1form').fadeOut();					/// controls visible... hide the
			$('#p2form').fadeOut();					// join forms
		} else {
		// the bindName function returned false, which should almost certainly
		// point to catastrophic failure... log the event, and return false end func.
			console.log('bindName returned false.');
			return false;							// return false to exit the function
		}
			$("#p1form").fadeOut();
			$("#p1play").fadeIn();
				$("#chatform").fadeIn();
				if ($('#chatform').attr("style") === "display: none;") {
			}
		}
	});
	// listen for player 2's join button
	$("#p2join").click(function(event) {
		var pnum = 2;
		var nick=$("#p2nameinput").val();
		if (nick == "" || nick == undefined) {
			nick = "Anon2"
		}
		var status = fb.bindName(pnum, nick);

			$("#p2form").fadeOut();
			$("#p2play").fadeIn();
			if ($("#chatform").attr("style") === "display: none;") {
				$("#chatform").fadeIn();
			}

	});
	// listen for the send button
	$("#send-btn").click(function(event) {
		var msgval = $('#chat-msg').val();
		var tstamp = Date.now()
		if (msgStr.length < 1) {
			console.log("Can't post an empty message... aborted.");
			fb.printAlert("Failed to post a chat message.  Reason: User didn't specify a message");
		}
		db.recordMessage(msgval, this.uid, msgStr, tstamp, false);
	});
	$("#p1-rock-btn").click(function(event) {

	});
	// fb.init();
// });
$(document).ready(fb.init());
